<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Web Nghe Nh·∫°c</title>
    <link rel="stylesheet" href="../static/style/musicpage.css">
</head>

<body>
    <h1>üéµ Danh s√°ch b√†i nh·∫°c üéµ</h1>

    <div class="music-list">
        {% for file in music_files %}
        <div class="music-card">
            <p class="music-title">{{ file }}</p>
            <audio controls>
                <source src="{{ url_for('play_music', filename=file) }}" type="audio/mpeg">
                Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ audio.
            </audio>
        </div>
        {% endfor %}
    </div>
    {% if role == 'artist' %}
    <a href="/upload">Upload Music</a>
    {% endif %}
    <script>
        async function hexToArrayBuffer(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes.buffer;
        }

        async function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        async function main() {
            const res = await fetch("/key-exchange");
            const {
                server_pubkey_ecdhe,
                signature,
                server_pubkey_ecdsa
            } = await res.json();

            const ecdheBuf = await hexToArrayBuffer(server_pubkey_ecdhe);
            const sigBuf = await hexToArrayBuffer(signature);
            const ecdsaBuf = await hexToArrayBuffer(server_pubkey_ecdsa);

            // 1. Import ECDSA public key t·ª´ raw
            const serverECDSAPubKey = await crypto.subtle.importKey(
                "spki", // chu·∫©n X.509
                ecdsaBuf,
                { name: "ECDSA", namedCurve: "P-256" },
                true,
                ["verify"]
            );

            // 2. X√°c minh ch·ªØ k√Ω
            const verified = await crypto.subtle.verify(
                { name: "ECDSA", hash: "SHA-256" },
                serverECDSAPubKey,
                sigBuf,
                ecdheBuf
            );

            if (!verified) {
                alert("‚ùå Ch·ªØ k√Ω c·ªßa server kh√¥ng h·ª£p l·ªá");
                return;
            }

            console.log("‚úÖ Server signature verified");

            // 3. Import public key ECDHE
            const serverECDHPubKey = await crypto.subtle.importKey(
                "raw",
                ecdheBuf,
                { name: "ECDH", namedCurve: "P-256" },
                true,
                []
            );

            // 4. T·∫°o keypair ECDHE ph√≠a client
            const clientKeys = await crypto.subtle.generateKey(
                { name: "ECDH", namedCurve: "P-256" },
                true,
                ["deriveBits"]
            );

            // 5. T√≠nh shared secret
            const sharedSecret = await crypto.subtle.deriveBits(
                {
                    name: "ECDH",
                    public: serverECDHPubKey
                },
                clientKeys.privateKey,
                256
            );

            console.log("üîê Shared secret (client):", await arrayBufferToHex(sharedSecret));

            // 6. G·ª≠i public key client l√™n server
            const clientPubRaw = await crypto.subtle.exportKey("raw", clientKeys.publicKey);
            const clientPubHex = await arrayBufferToHex(clientPubRaw);

            await fetch("/submit-client-key", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ client_pubkey_ecdhe: clientPubHex })
            });
        }

        main();
    </script>

</body>

</html>